__¿Cuáles son los `style encapsulation` de los componentes? Pon un ejemplo de uso de cada uno de ellos.__

Se refiere al hecho de que en Angular, por defecto, los estilos asignados a los componentes no afectan a los elementos circundantes a o descendientes de esos componentes. Angular sin embargo, tiene la opción de cambiar esta configuración, a través de la especificación de un atributo `encapsulation` en el elemento. Este atributo de encapsulación se puede dar de diversas siguientes formas, según los valores que tome:

* `ViewEncapsulation.Emulated`: Angular emulará el comportamiento del `shadow DOM` añadiéndole un atributo único al elemento padre del componetne y encapsulando los estilos al componente del que es atributo. Esto significa que el estilo aplicado en la hoja de estilos del componente solo se aplicará a los elementos interiores de la plantilla del componente, y no se aplicará a otras partes de la aplicación. Un ejemplo de uso de este tipo de encapsulamiento podría darse en un ítem de una tienda de Ecommerce, el cual queremos que posea estilos específicos que no afecten al código adyacente.

* `ViewEncapsulation.Native`: al contrario del método anterior, que usa el _scoping_ para encapsular los estilos, esta forma utiliza el `shadow DOM` nativo del navegador para realizarlo. Esto significa que se require soporte para `shadow DOM` nativo por parte del navegador, lo cual no ocurre en navegadores más antiguos. Ya que el método anterior implica la generación de más reglas CSS que tienen que ser procesadas por el navegador, el método de encapsulamiento nativo produce mejores resultados en cuanto a rendimiento. Un ejemplo de uso sería una situación parecida al caso anterior, en al que se requiere de un tiempo de carga menor, por ejemplo, casos en los que se deban cargar una gran cantidad de componentes a la vez, como podría serlo en una página de una universidad en la que se genera una ficha por cada alumno de un aula.

* `ViewEncapsulation.None`: este método de encapsulación utiliza CSS global, por lo que, en realidad, no se realiza ningún tipo de encapsulación. Esto puede ser útil cuando se diseñe un componente con componentes hijos que queremos que posean estilos similares a los del padre. Por ejemplo, cuando estamos diseñando un componente para un artículo de un proyecto de ecommerce, y queremos diseñar un componente dentro de ese componente específicamente para englobar las características del artículo, es posible que queramos que ciertos aspectos del estilo del componente padre se reflejen en el hijo.

__¿Qué es el `shadow DOM`?__

Se trata de un estándar web que permite encapsular el código de marcado, estilso y comportamiento de un componente web de forma que pueda ser usado en uan página sin afectar a otras partes de la misma. Funciona creando un árbol paralelo para cada componente, que se considera como una parte separada del DOM y que se adjunta al documento principal en algún punto del mismo.

__¿Qué es el `changeDetection`?__

De forma predeterminada, Angular comprueba cada _binding_ en la interfaz para ver si necesita actualizar algún elemento cada vez que se dan cambios en los valores del componene. Cuando la aplicación posee un tamaño superior, esto puede aceptar al rendimiento si se hace de forma generalizada, por lo que Angular ofrece la opción de decidir si necesita actualizar la UI para ese componente. Esto se realiza a través del atributo `changeDetection`.

__¿Qué diferencias existen entre las estrategias `Default` y `OnPush`? ¿Cuándo debes usar una y otra? Ventajas e inconvenientes.__

* La estrategia `Default` de detección de cambios se da por defecto en los componentes de Angular. Angular, entonces, detecta cada cambio en el componente y en los hijos del componente, y actualiza el DOM según sea necesario. __Ventajas__: es más fácil de usar e implementar ya que ocurre por defecto, tiene más sentido usarla en aplicaciones de pequeña envergadura y con jerarquías de componentes simples, y es óptima cuando has desarrollado una aplicación que requiera actualizaciones constantes. __Desventajas__: puede resultar más lenta e ineficiente en aplicaciones de mayor tamaño o cuando existen jerarquías complejas, realizar demasiadas comprobaciones y actualizaciones puede causar problemas de rendimiento.

* La estragia `OnPush`, más basada en el rendimiento, puede usarse para optimizar el proceso de detección de cambios, ya que Angular solo comprobará los _bindings_ de un componente y sus componentes hijo cuando una propiedad _input_ del componente cambie, si el componente emite un evento al cual está suscrito el componente padre, o cuando la referencia del componente cambia. __Ventajas__: esta estrategia reduce signficativamente el número de ciclos de detección de cambios en la aplicación, aumentando el rendimiento; funciona bien en aplicaciones de mayor envergadura con jerarquías de componentes complejas porque solo realiza comprobaciones cuando se es necesario; y puede ayudar a reducir la innecesaria renderización consecutiva de componentes que no lo necesitan. __Desventajas__: requiere mayor vigilancia en el diseño de componentes para asegurarse de que no se quedan componentes sin comprobación cuando esta es necesaria, los desarrolladores deben estar más atentos a cualquier cambio que deba realizar actualizaciones eb la aplicación, y puede resultar más difícil de implementar.

Respecto a la cuestión de __cuándo se debe usar una u otra__: la estrategia `Default` debería usar se en aplicaciones de menor tamaño con jerarquías de componentes menos complejas y en casos en los que se esté desarrollando una aplicación que requiera de una actualización frecuente de los datos. `On push` debería usarse en aplicaciones de mayor tamaño, con jerarquías complejas y/o cuando la necesidad de actualización de los componentes no sea tan imperante.

__Explica con detalle el ciclo de vida de los componentes. Haz hincapié en cuándo se disparan los _hooks_ `OnChanges`, `OnInit`, `AfterViewInit` y `OnDestroy`, puesto que son los más utilizados.__

El ciclo de vida de los componentes de angular pasa por las fase de creación, renderización, cambio y destrucción. Estos pasos se desarrollan en forma de árbol transversal, de arriba a abajo. Se trata de los siguientes:

1. Lo primero que actúa es el constructor.
2. Seguidamente, actúa el hook `OnChanges`. Este es llamado cada vez que una propiedad `input` del componente cambia y cuando el constructor es ejecutado. Se llama antes que el `onInit` _hook_.  
3. A continuación, se dan los procesos que ocurren cuando el componente es inicializado. Este es `onInit`. Permite la realización de cualquier inicialización única al componente o directiva. Es el momento ideal para cargar datos del servidor y similares, en lugar de realizarlo a través del constructor, por razones de separación de problemas y para poder realizar un testeo más sencillo.
4. Seguidamente, actúa `DoCheck`. Este anima a Angular a realizar una comprobación si hay _bindings_ o cambios que Angular debería o no debería detectar por sí mismo. Es una de la formas que tenemos de avisar a angular de un cambio en un componente cuando cambiamos `changeDetection` de `Default` a `OnPush`. `Do Check` se aplica tanto a componentes como a directivas.
5. `AfterContentInit` actúa a continuación. Ocurre durante los casos de proyección de componentes, y solo se da una vez durante la inicialización del componente. Si no hay proyección, se da inmediatamente.
6. Se ejecuta `AfterContentChecked` cada vez que se da el ciclo de detección de cambios de Angular. En caso de ser la iniciación, se da justo después de `AfterContentInit`.
7. `AfterViewInit` es el complemento a `AfterContentInit`. Se ejecuta cuando todos los componentes hijos que se usan en la plantilla del componente han acabado de inicializarse, y su vista se ha actualizado con _bindings_. Esto no quiere decir necesariamente que las vistas se se hayan renderizado en el navegador, sino que Angular a terminado de organizar sus vistas internas para renderizar lo más pronto posible. Esta fase solo se ejecuta una vez durante toda la fase de carga.
8. `AfterViewChecked` se da cada vez que todos los componentes hijos se han comprobado y actualizado.
9. El _hook_ `OnDestroy` es llamado cuando un componente va a ser destruido y eliminado de la interfaz. Se suele usar para realizar limpieza, eliminando _event listeners_ que se hayan inicializado en componentes que no van a estar ya presentes, etc.  